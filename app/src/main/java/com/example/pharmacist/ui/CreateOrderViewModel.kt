package com.example.pharmacist.ui

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.pharmacist.domain.model.*
import com.example.pharmacist.domain.repository.DrugRepository
import com.example.pharmacist.domain.repository.OrderRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import java.time.OffsetDateTime
import javax.inject.Inject
import android.util.Log

@HiltViewModel
class CreateOrderViewModel @Inject constructor(
    private val orderRepository: OrderRepository,
    private val drugRepository: DrugRepository
) : ViewModel() {
    private val _drugs = MutableStateFlow<List<Drug>>(emptyList())
    val drugs: StateFlow<List<Drug>> = _drugs.asStateFlow()

    private val _selectedDrugs = MutableStateFlow<Map<DrugId, Int>>(emptyMap())
    val selectedDrugs: StateFlow<Map<DrugId, Int>> = _selectedDrugs.asStateFlow()

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()

    init {
        loadDrugs()
    }

    private fun loadDrugs() {
        viewModelScope.launch {
            try {
                _isLoading.value = true
                _error.value = null
                _drugs.value = drugRepository.getDrugs()
            } catch (e: Exception) {
                _error.value = "Failed to load drugs: ${e.message}"
            } finally {
                _isLoading.value = false
            }
        }
    }

    fun updateDrugQuantity(drugId: DrugId, quantity: Int) {
        val currentMap = _selectedDrugs.value.toMutableMap()
        if (quantity <= 0) {
            currentMap.remove(drugId)
        } else {
            currentMap[drugId] = quantity
        }
        _selectedDrugs.value = currentMap
    }

    private suspend fun validateDrugs(selectedDrugs: Map<DrugId, Int>): Boolean {
        return selectedDrugs.all { (drugId, _) ->
            drugRepository.getDrugById(drugId) != null
        }
    }

    fun createOrder(onSuccess: () -> Unit) {
        if (_selectedDrugs.value.isEmpty()) {
            _error.value = "Please select at least one drug"
            return
        }

        viewModelScope.launch {
            try {
                _isLoading.value = true
                _error.value = null

                // Validate all drugs exist
                if (!validateDrugs(_selectedDrugs.value)) {
                    _error.value = "One or more selected drugs no longer exist"
                    return@launch
                }

                val orderItems = _selectedDrugs.value.map { (drugId, quantity) ->
                    val drug = _drugs.value.find { it.id == drugId }
                        ?: throw IllegalStateException("Drug not found")
                    
                    OrderItem(
                        id = "",  // Will be generated by the backend
                        drugId = drugId,
                        quantity = quantity,
                        price = 10.0  // You might want to get this from the drug or elsewhere
                    )
                }

                val order = Order(
                    id = "",  // Will be generated by the backend
                    userId = "",  // Should come from auth
                    status = OrderStatus.PENDING,
                    items = orderItems,
                    createdAt = OffsetDateTime.now().toString(),
                    updatedAt = OffsetDateTime.now().toString()
                )

                orderRepository.createOrder(order)
                onSuccess()
            } catch (e: Exception) {
                Log.e("CreateOrderViewModel", "Error creating order", e)
                _error.value = "Failed to create order: ${e.message}"
            } finally {
                _isLoading.value = false
            }
        }
    }

    fun clearError() {
        _error.value = null
    }
} 